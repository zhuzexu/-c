一：
    继承分为   (1)继承虚拟接口（头文件函数指针，父类无实现方法）
               (2)继承父类接口的实现方法。
    在此基础上才有了多态和重载。  
        其中多态包含两方面：1.子类新增了方法接口    2.各个子类有着不同的父类虚接口实现方法。    
        而重载：类中同名函数依据不同参数，有着不同的实现方法。{用可变参数可实现，暂不用。--->新增几个不同名的函数指针接口实现}
        
    此外，封装时都带有void *priv成员，方便使用时扩展。

二：
    封装除外，大概有四种接口要留出：1. init(仅填充)  2. deinit（仅去填充）  3. create (malloc+init)   4.delete(free+deinit)  。
    注：1.2用于对象在子类（上层定义）  3.4则在底层父类申请并定义。---灵活使用。


三：
    对于上面4种接口深入理解：
    对象分类：单实例永存，单实例临时，多实例永存，多实例临时。
    用init/deinit时需要调用者提供类变量即对象自身（应用于永存实例的比较合适），同时配备get句柄，多个对象存在时注意统一管理。
    用create/destroy时是底层自动管理内存分配释放。（应用于临时实列较好，尤其是算法等临时多实例）

    注：若是抽象接口.h存在接口自身的方法实现，对于永恒实例，对象的.c中不赞同直接定义对象变量的方式(即静态全局变量)，后get句柄。原因是假如用父类抽象接口的实现方法，那么父类的.h需要开放函数接口供对象的.c使用，乱！
        而.h只有虚拟接口或纯数据结构，具体实现方法全由对象实现的，对于永恒实例则推荐各个对象.c直接定义，简单明了。{统一起见，使用"建议五"的方式，新建子类.h包含父类.h，实现父类方法的继承或多态。}

    结构体：子类数据结构包含父类数据结构时，父类结构体成员只有是单实例永久时必须用指针，其他情形的话用变量或者指针都可以，推荐用变量。 
    
    
四：
    c语言.h头文件的结构体封装类似于class的接口抽象（.c存在的话可能有父类的公用实现方法）。
    
    1.---借助.h生成的对象，且只用类的init接口是对class最基本的继承（对象使用了类的方法，可以理解为继承的原因是各个子对象可以本身修改class自身对应的方法）。
        若对象调用类的init后仍需改动接口，运用类接口set_interface更改后，即"变向"实现了这个类相关接口的多态或者重写。
        
    2.---而新子类.h文件包含父类.h的头文件（新子类.h必须新增方法接口，否则无必要新建子类.h），是真正意义上对父类接口的继承且拓展多态。
    
    3.---父类中不实现的虚接口，应提供默认空方法。


五：
    //父类原始方法
    bb_xxxx(BB * bb)
    {
        return bb.ll;
    }

    //子类重写方法
    aa_xxxx(BB * bb)  <---------------------
    {                                       |
        return bb.ll + bb.uu;               |
                                            |
        //要是用到子类AA的资源？？            |
        AA *aa = container_of(...);         |
        //其他逻辑XXX....                    |
    }                                       |
                                            |
    子类初始化：                             |
    aa.init()                               |
    {                                       |
      先递归父类初始化                       |
      aa.bb.init()                          |
      {                                     |
        bb.init = bb_xxxx(BB * bb);         |
      }                                     |
      若子类重写，再赋值。                    |
      aa.bb.bb_xxx_func = aa_xxxx(BB *);    |
    }                                       |
                                            |
    aa_xxxx_func(AA *aa)                    |
    {                                       |
        aa.bb.bb_xxx_func(&aa.bb);----------
    } 

    使用时两种方式 :建议用2，看着不累。
        1. 子类不封装直接用2
         aa.bb.bb_xxx_func(&aa->bb);
        2. 子类重新封装接口
         aa.aa_xxxx_func(AA *aa);







