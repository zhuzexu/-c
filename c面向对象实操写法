基于面向对象的c，按道理来讲必须有类和对象，且一一对应使用。若对象新增方法则继承父类新增子类，再次建立子类对象使用。
      类(struct)：  [ .h(接口)  .c(共有方法)]
	 |
	 |
     对象(type) ：  [ .c(实现多态，重写类方法)  .h(对象的初始化接口对外部使用)]

	 
################################################################### 实际使用 START #####################################################################################

原因：(1)C语言的缺陷，建立对象后必须开放新接口“对象.h”供使用。文件书写繁琐。
      (2)有许多关于硬件驱动的处理，一定为单实例，即类的接口(.h)不外用。也不建议另起文件新建对象。
      (3)除了公用模块工具、可高度抽象的抽象类接口(.h供多个实例使用)外，其他的类几乎所有部分都是单实例的(多态化的本质)。终端类(具象类)也不适合另起文件新建对象。
	 
所以用如下法则，简言之将对象的建立放到类的实现.c中去，既做到面向对象的属性，也代码结构简单优雅。
	 
      1.无需抽象层的纯单一实例(硬件相关模块)：将类和对象的.h.c合二为一，节省掉对象的.c.h文件，其中.h作为接口，.c作为实现，.c中的私有数据最好用私有结构体封装不开放。
	对外接口3个即可： object_init(设置is_init，除了初始化私有数据外，并赋值式初始化对外开放接口以及设置回调等)  
			 object_deinit  
			 object_get_handler(获取对外开放接口对象句柄)
						   
      2."建立在1基础之上的"最常见案例--继承父类struct接口的各个单一实例(终端具象类)：
	要做到 @继承（直接使用父类方法）、@重写父类方法（父类接口有set_interface用于修改默认方法，或者用于动态更换其他接口，子类实现父类接口写法参考感悟）、@多态(对象或子类对象接口赋值多态)。
		 
        分为两类 <a>子类不增加接口或属性的多态：即父类的纯对象，此类只好新建对象.c .h。
                   新建对象.h 3个接口：  object_init（调用父类init）              object_create
	                                object_deinit（调用父类deinit）   或     object_destroy
			                object_get_handler   
		 
		 
	        <b>子类增加接口或属性的多态：不新建子类struct，将子类和子类对象的.h.c合二为一，只不过子类的.h包含了父类接口。其他参考1
	           子类对象.h 3个接口： object_init（调用父类init）              object_create
		                       object_deinit（调用父类deinit）   或     object_destroy
			               object_get_handler   
										 
		                       调用时pfarther = &son.father; 
					     pfarther->func_farther(pfarther, param1, param2);
					     son.func_son(&son, param1, param2);
										  
       
       3. 2<a>中比较特殊<对象多个>: 绝大部分的接口是虚类的，否则就是2<a>. 此种类型用常规方式init的话参数繁琐且无效难看！其中又分为两类：抽象类中全部虚接口和绝大部分虚接口。
	   
	   编写形式：各个对象.h 直接使用虚接口.h（不新建），若有少部分公共已实现方法可以单独新建个公共.c 或者直接虚接口.h 加inline包含。
	             a:各个对象.c 实现自己的方法，直接静态全局变量方式。虚接口.h 中数组管理调用使用（虚接口.c 中extern出来写获取接口！）。简单直观。
		     b:或者动态方式init中用自己的方法直接初始化各个虚类接口，对外提供init/deinit/get_handler接口头，可以直接放在虚接口.h 中共同管理（虚接口.c 中extern出来写获取接口！）。
		       相当于“1”，只不过不单独将虚接口的实现作为一个独立的类，而是作为【公共方法】嵌入到每个对象.c 中去，同步初衷。
		     
		     当然每个具体实例对象.c ：按照惯例用结构体封装好自己的私有数据（可含is_init等），然后各个虚接口实例操作之！
		     初衷：尽量少建无用文件。
       
       
       4.作为可多实例化的类，包含两种（工具类、高度抽象的父类），无对象类的常规操作。
         4个接口:    class_init           
		    class_deinit
                    class_create										  
		    class_destroy	
					
	
针对多级继承问题，中级类一定不是终端具象类的写法，否则无法被继承。终端类若需要多实例可以按3的方法实现（写法参考感悟篇）。绝大多数直接是2中<b>的方式。
										

################################################################### 实际使用 END #####################################################################################
